// Generated by transforming |cwd:///parser/2.7.2.y| on 2016-10-15 at 17:11:42 +0000
%{
  #include <iostream>
  #include <cmath>
  #include <iomanip>
  #include <fenv.h>
  #include <string>
  #include <cstring>
  #include <vector>
  #include "ast.h"


	int yylex (void);
	int printflag;
	extern int yylineno;
	extern char *yytext;
	void yyerror (char const *);
	
%}

%union {
  Ast* ast;
  int inum;
  float fnum;
  char* mystring;
  std::vector<Ast*>* myvec;
  //enum action;
}

// 83 tokens, in alphabetical order:
//%token <action> PLUS
//%type <inum>  pick_unop
%type <mystring> INUMBER
%type <mystring> FNUMBER
%type <mystring> NAME
%token AMPEREQUAL AMPERSAND AND AS ASSERT AT BACKQUOTE BAR BREAK
%token CIRCUMFLEX CIRCUMFLEXEQUAL CLASS COLON COMMA CONTINUE DEDENT
%token DEF DEL DOT DOUBLESLASH DOUBLESLASHEQUAL 
%token DOUBLESTAR DOUBLESTAREQUAL ELIF ELSE ENDMARKER EQEQUAL PLUS
%token EQUAL EXCEPT EXEC FINALLY FOR FROM GLOBAL GREATER GREATEREQUAL GRLT
%token IF IMPORT IN INDENT IS LAMBDA LBRACE LEFTSHIFT LEFTSHIFTEQUAL LESS
%token LESSEQUAL LPAR LSQB MINEQUAL MINUS NAME NEWLINE NOT NOTEQUAL
%token OR PASS PERCENT PERCENTEQUAL PLUSEQUAL PRINT RAISE 
%token RBRACE RETURN RIGHTSHIFT RIGHTSHIFTEQUAL RPAR RSQB 
%token SEMI SLASH SLASHEQUAL STAR STAREQUAL 
%token STRING TILDE TRY VBAREQUAL WHILE WITH YIELD INUMBER FNUMBER

%type <myvec> plus_stmt suite 


%type <ast> factor term test opt_comp_for comp_for lambdef argument or_test
%type <ast> exprlist single_input start opt_arglist arglist simple_stmt
%type <ast> opt_test and_test not_test comparison expr xor_expr and_expr
%type <ast> shift_expr arith_expr pick_multop
%type <ast> power atom star_trailer trailer opt_yield_test pick_yield_expr_testlist_comp
%type <ast> testlist_comp listarg dictarg yield_expr encoding_decl
%type <ast> NEWLINE compound_stmt small_stmt testlist file_input star_NEWLINE_stmt
%type <ast> if_stmt while_stmt for_stmt try_stmt with_stmt funcdef classdef decorated
%type <ast> opt_listmaker opt_dictorsetmaker testlist1 decorators parameters expr_stmt
%type <ast> print_stmt del_stmt pass_stmt flow_stmt import_stmt global_stmt exec_stmt assert_stmt
%type <ast> star_ELIF decorator varargslist STAR dotted_name pick_NEWLINE_stmt
%type <ast> DOUBLESTAR YIELD comp_iter comp_if old_test COLON CLASS IF FOR IN DOT LAMBDA with_item
%type <ast> dictorsetmaker listmaker plus_STRING subscriptlist PLUS pick_PLUS_MINUS pick_unop MINUS
%type <ast> except_clause opt_AS_COMMA subscript star_COMMA_test raise_stmt opt_COMMA_test opt_test_3
%type <ast> opt_testlist pick_yield_expr_testlist augassign opt_ELSE opt_FINALLY opt_IF_ELSE
%type <ast> opt_test_only sliceop star_EQUAL small_stmt_STAR_OR_SEMI return_stmt stmt
%start start 


%%

start
	: file_input                   { }//std::cout << $1->myeval() << std::endl;   }
	| encoding_decl
	| single_input    				{}// std::cout << $1->myeval() << std::endl;  }
	;
//single_input // Used in: start
//	: NEWLINE
//	| simple_stmt
//	| compound_stmt NEWLINE
//	;

single_input // Used in: start
	: NEWLINE
	| stmt 							
	{

	   if($1->getNodetype().compare("var") == 0) {
	
	   }
	   else{
	     // std::cout << " single_input " << $1->myeval() <<  std::endl; $$ = $1; 
	      
	   }
	}
	;
file_input // Used in: start
	: star_NEWLINE_stmt ENDMARKER
	;
pick_NEWLINE_stmt // Used in: star_NEWLINE_stmt
	: NEWLINE
	| stmt                              { 

	    if($1->getNodetype().compare("funcdef") == 0 ){
	    }
	    else{
	    	$1->myeval();
	    }	
	    	 
		   
	   // }
	   // else{
		//std::cout << $1->myeval() <<  std::endl;
		

	   // tableManager& tabmgr = tableManager::getInstance(); 
	    //int scope = tabmgr.getScope();
	    // tabmgr.pushScope(0);
	  // }
	    }
	;
star_NEWLINE_stmt // Used in: file_input, star_NEWLINE_stmt
	: pick_NEWLINE_stmt star_NEWLINE_stmt          { $$=$1; }//std::cout << $1->getNodetype() << " star_NEW" << std::endl; }
    | %empty                                       {}
    ;
decorator // Used in: decorators
	: AT dotted_name LPAR opt_arglist RPAR NEWLINE {}
	| AT dotted_name NEWLINE                        {}
	;
opt_arglist // Used in: decorator, trailer
	: arglist                      { $$ = $1; }
	| %empty                         {}
	;
decorators // Used in: decorators, decorated
	: decorator decorators
	| decorator
	;
decorated // Used in: compound_stmt
	: decorators classdef
	| decorators funcdef
	;
funcdef // Used in: decorated, compound_stmt
	: DEF NAME {
		 tableManager& tabmgr = tableManager::getInstance(); 
         int scope = tabmgr.getScope();
         tabmgr.pushScope(++scope); } parameters COLON suite {
			std::string funcname($2);
	    	funcname.append("()");

	    	$$ = new AstFunc("funcdef", funcname, $6);

	    	tableManager& tabmgr = tableManager::getInstance();
	    	int scope = tabmgr.getScope();
	    	tabmgr.pushScope(--scope);
	    	tabmgr.setVal(funcname, $$);

	    	//std::cout << "astfunc funcdef " << std::endl;
	} 	
	;
parameters // Used in: funcdef/////***************************************////
	: LPAR varargslist RPAR					{ }//std::cout << "parameters" << std::endl; }
	| LPAR RPAR								{ }//std::cout << "parameters" << std::endl; }
	;
varargslist // Used in: parameters, old_lambdef, lambdef
	: star_fpdef_COMMA pick_STAR_DOUBLESTAR			{ std::cout << "varargslist" << std::endl; }
	| fpdef opt_EQUAL_test star_COMMA_fpdef			{ std::cout << "varargslist " << std::endl; }
	;
opt_EQUAL_test // Used in: varargslist, star_fpdef_COMMA, star_COMMA_fpdef
	: EQUAL test                              {}// std::cout << "opt_EQUAL_test" << $2->getNumber() << std::endl; }
	| %empty                                  {}
	;
star_fpdef_COMMA // Used in: varargslist, star_fpdef_COMMA
	: fpdef opt_EQUAL_test COMMA star_fpdef_COMMA
	| %empty
	;
opt_DOUBLESTAR_NAME // Used in: pick_STAR_DOUBLESTAR
	: COMMA DOUBLESTAR NAME
	| %empty
	;
pick_STAR_DOUBLESTAR // Used in: varargslist
	: STAR NAME opt_DOUBLESTAR_NAME
	| DOUBLESTAR NAME
	;
fpdef // Used in: varargslist, star_fpdef_COMMA, fplist, star_fpdef_notest, star_COMMA_fpdef
	: NAME                                          { std::cout << "fpdef" << std::endl; }
	| LPAR fplist RPAR                        { std::cout << "fpdef" << std::endl; }
	;
fplist // Used in: fpdef
	: fpdef star_fpdef_notest       { std::cout << "fplist" << std::endl; }
	;
stmt // Used in: pick_NEWLINE_stmt, plus_stmt
	: simple_stmt   								{  $$ = $1; }//std::cout << $1->myeval() << " stmt "<< $1->getNodetype() << std::endl; }
	| compound_stmt                                 {  $$ = $1; }//std::cout << "stmt -compound_stmt "<< $1->getNodetype() << std::endl; }
	;
simple_stmt // Used in: single_input, stmt, suite
	: small_stmt small_stmt_STAR_OR_SEMI NEWLINE      {  $$ = $1; }//std::cout <<"simple_stmt " << std::endl;}
	;
small_stmt // Used in: simple_stmt, small_stmt_STAR_OR_SEMI
	: expr_stmt                        {  $$ = $1; }//std::cout << "small_stmt "  << std::endl; }
	| print_stmt                        {  $$ = $1; }
	| del_stmt
	| pass_stmt
	| flow_stmt
	| import_stmt
	| global_stmt
	| exec_stmt                   {  $$ = $1; std::cout << "small_stmt exec"  << std::endl; }
	| assert_stmt
	;
expr_stmt // Used in: small_stmt
	: testlist augassign pick_yield_expr_testlist        { 
       $2->setNodes($1, $3); $$ = $2; }
	| testlist star_EQUAL        {  
        //std::cout << $1->getKey() << $2->getNumber() << std::endl;
	    if($1->getNodetype().compare("var") == 0){
		   std::string tempKey($1->getKey()); 
		   $1->setVal($2->getNumber());

		   tableManager& tabmgr = tableManager::getInstance();
		   tabmgr.setVal(tempKey, $1);
		   
	     }
	  
	  

	$$ = $1; 
	}
	;
pick_yield_expr_testlist // Used in: expr_stmt, star_EQUAL
	: yield_expr        { $$ = $1; }//std::cout << "pick_yield_expr_testlist"<<  std::endl;}
	| testlist                 { $$ = $1; }// std::cout << "pick_yield_expr_testlist"<< $1->getNodetype()   << std::endl;}
	;
star_EQUAL // Used in: expr_stmt, star_EQUAL
	: EQUAL pick_yield_expr_testlist star_EQUAL   { $$ = $2; }//std::cout << "star_EQUAL " << $2->getNodetype()  << std::endl;  }
	| %empty                                      {}
	;
augassign // Used in: expr_stmt
	: PLUSEQUAL                             { $$ = new AddNode("plusequal"); }
	| MINEQUAL                              { $$ = new SubNode("subequal"); }
	| STAREQUAL                             { $$ = new MultNode("multequal"); }
	| SLASHEQUAL                            { $$ = new DivNode("divequal"); }
	| PERCENTEQUAL                          { $$ = new ModNode("modequal"); }
	| AMPEREQUAL                            {}
	| VBAREQUAL                             {}
	| CIRCUMFLEXEQUAL                       {}
	| LEFTSHIFTEQUAL                        {}
	| RIGHTSHIFTEQUAL                       {}
	| DOUBLESTAREQUAL                       {}
	| DOUBLESLASHEQUAL                      { $$ = new DivDivNode("2slashequal"); }
	;
print_stmt // Used in: small_stmt
	: PRINT opt_test
    { 

        $$ = new AstPrint("print", $2);
    } 
	| PRINT RIGHTSHIFT test opt_test_2		{}	
	;
opt_test // Used in: print_stmt
	: test star_COMMA_test   			{  $$ = $1; }//std::cout << "opt_test " << std::endl; }
	| %empty                                {}
	;
opt_test_2 // Used in: print_stmt
	: plus_COMMA_test
	| %empty
	;
del_stmt // Used in: small_stmt
	: DEL exprlist 							{}
	;
pass_stmt // Used in: small_stmt
	: PASS 									{}
	;
flow_stmt // Used in: small_stmt
	: break_stmt 							{}
	| continue_stmt    						 {}
	| return_stmt  							 { $$ = $1; }
	| raise_stmt  							  {}
	| yield_stmt 							{}
	;
break_stmt // Used in: flow_stmt
	: BREAK
	;
continue_stmt // Used in: flow_stmt
	: CONTINUE
	;
return_stmt // Used in: flow_stmt
	: RETURN testlist               { $$ = new AstReturn("return", $2); }//std::cout << "return_stmt"<< $2->getNodetype()   << std::endl;}
	| RETURN                         {}
	;
yield_stmt // Used in: flow_stmt
	: yield_expr
	;
raise_stmt // Used in: flow_stmt
	: RAISE test opt_test_3            { $$ = $2; }//std::cout << "raise_stmt" << std::endl; }
	| RAISE                            {}
	;
opt_COMMA_test // Used in: opt_test_3, exec_stmt
	: COMMA test                          {  $$ = $2; }//std::cout << "opt_COMMA_test" << std::endl;}
	| %empty                                   {}
	;
opt_test_3 // Used in: raise_stmt
	: COMMA test opt_COMMA_test             {  $$ = $2; }//std::cout << "opt_test_3" << std::endl;}
	| %empty                                {}
	;
import_stmt // Used in: small_stmt
	: import_name   						{}
	| import_from 							{}
	;
import_name // Used in: import_stmt
	: IMPORT dotted_as_names
	;
import_from // Used in: import_stmt
	: FROM star_DOT dotted_name IMPORT pick_STAR_import
	| FROM plus_DOT IMPORT pick_STAR_import
	;
star_DOT // Used in: import_from, star_DOT
	: DOT star_DOT
	| %empty
	;
plus_DOT // Used in: import_from, plus_DOT
	: DOT plus_DOT
	| DOT
	;
pick_STAR_import // Used in: import_from
	: STAR
	| LPAR import_as_names RPAR
	| import_as_names
	;
import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: NAME AS NAME                       { std::cout << "import_as_name" << std::endl; }
	| NAME                               { std::cout << "import_as_name" << std::endl; }
	;
dotted_as_name // Used in: dotted_as_names
	: dotted_name AS NAME
	| dotted_name
	;
import_as_names // Used in: pick_STAR_import
	: import_as_name star_COMMA_import_as_name
	;
dotted_as_names // Used in: import_name, dotted_as_names
	: dotted_as_name
	| dotted_as_names COMMA dotted_as_name
	;
dotted_name // Used in: decorator, import_from, dotted_as_name, dotted_name
	: NAME                                        { std::cout << "dotted_name" << std::endl; }
	| dotted_name DOT NAME
	;
global_stmt // Used in: small_stmt, global_stmt
	: global_stmt COMMA NAME
	| GLOBAL NAME    							{ 
		std::string var($2); 
		tableManager& tabmgr = tableManager::getInstance();
		tabmgr.setGlobal(var);}
	;
exec_stmt // Used in: small_stmt
	: EXEC expr IN test opt_COMMA_test 			{std::cout << "exec_stmt" << std::endl;}
	| EXEC expr 								{ std::cout << "exec_stmt" << std::endl;}
	;
assert_stmt // Used in: small_stmt
	: ASSERT test COMMA test 					{std::cout << "assert_stmt" << std::endl;}
	| ASSERT test 								{std::cout << "assert_stmt" << std::endl;}
	;
compound_stmt // Used in: single_input, stmt
	: if_stmt
	| while_stmt
	| for_stmt
	| try_stmt
	| with_stmt
	| funcdef                 {  $$ = $1; }//std::cout << "compound stmt" << std::endl; }
	| classdef
	| decorated
	;
if_stmt // Used in: compound_stmt
	: IF test COLON suite star_ELIF ELSE COLON suite    { std::cout << "if_stmt" << std::endl; }
	| IF test COLON suite star_ELIF                     { std::cout << "if_stmt" << std::endl; }
	;
star_ELIF // Used in: if_stmt, star_ELIF
	: ELIF test COLON suite star_ELIF        { std::cout << "star_ELIF" << std::endl;}
	| %empty                                 { std::cout << "star_Elif" << std::endl;}
	;
while_stmt // Used in: compound_stmt
	: WHILE test COLON suite ELSE COLON suite   { std::cout << "while_stmt" << std::endl;}
	| WHILE test COLON suite                    { std::cout << "while_stmt" << std::endl;}
	;
for_stmt // Used in: compound_stmt
	: FOR exprlist IN testlist COLON suite ELSE COLON suite     { std::cout << "for_stmt" << std::endl;}
	| FOR exprlist IN testlist COLON suite                      { std::cout << "for_stmt" << std::endl;}
	;
try_stmt // Used in: compound_stmt
	: TRY COLON suite plus_except opt_ELSE opt_FINALLY    {}
	| TRY COLON suite FINALLY COLON suite                 {}
	;
plus_except // Used in: try_stmt, plus_except
	: except_clause COLON suite plus_except                   { std::cout << "plus_except" << std::endl;}
	| except_clause COLON suite                               { std::cout << "plus_except" << std::endl;}
	;
opt_ELSE // Used in: try_stmt
	: ELSE COLON suite                                   { }//$$ = $3; }
	| %empty                                             {}
	;
opt_FINALLY // Used in: try_stmt
	: FINALLY COLON suite                                {}// $$ = $3; }
	| %empty                                             {}
	;
with_stmt // Used in: compound_stmt
	: WITH with_item star_COMMA_with_item COLON suite     {}
	;
star_COMMA_with_item // Used in: with_stmt, star_COMMA_with_item
	: COMMA with_item star_COMMA_with_item
	| %empty
	;
with_item // Used in: with_stmt, star_COMMA_with_item
	: test AS expr          { $$ = $1;  std::cout << "with_item" << std::endl;}
	| test                  { $$ = $1;  std::cout << "with_item" << std::endl;}
	;
except_clause // Used in: plus_except
	: EXCEPT test opt_AS_COMMA           {  $$ = $2; }//std::cout << "except_clause" << std::endl; }
	| EXCEPT                             {   }//std::cout << "except_clause" << std::endl;}
	;
pick_AS_COMMA // Used in: opt_AS_COMMA
	: AS
	| COMMA
	;
opt_AS_COMMA // Used in: except_clause
	: pick_AS_COMMA test                  { $$ = $2; }//std::cout << "opt_AS_COMMA" << std::endl;}
	| %empty                                  {}
	;
suite // Used in: ***funcdef, if_stmt, star_ELIF, while_stmt, for_stmt, 
      // try_stmt, plus_except, opt_ELSE, opt_FINALLY, with_stmt, classdef
	: simple_stmt                             { }// $$ = $1; std::cout << "suite" << std::endl;  }
	| NEWLINE INDENT plus_stmt DEDENT     { $$ = $3; }//std::cout << "suite -plus_stme" << std::endl; }
	;
plus_stmt // Used in: suite, plus_stmt
	: stmt plus_stmt                        {  
		$$ = $2;
		$$->push_back($1);

		//std::cout << " plus_stmt " <<std::endl;
		}
	| stmt                                  { 
	    $$ = new std::vector<Ast*>();
	    $$->push_back($1); 

	 // std::cout <<  "plus_stmt stmt" << std::endl;
	  }
	;
testlist_safe // Used in: list_for
	: old_test plus_COMMA_old_test
	| old_test 								
	;
old_test // Used in: testlist_safe, old_lambdef, list_if, comp_if, plus_COMMA_old_test
	: or_test 								    { }//std::cout << "old_test" << std::endl; }
	| old_lambdef 								{}
	;
old_lambdef // Used in: old_test
	: LAMBDA varargslist COLON old_test
	| LAMBDA COLON old_test
	;
test // Used in: *opt_EQUAL_test, *print_stmt, *opt_test, *raise_stmt, 
     // *opt_COMMA_test, *opt_test_3, *exec_stmt, *assert_stmt, *if_stmt, 
     // *star_ELIF, *while_stmt, *with_item, *except_clause, *opt_AS_COMMA, 
     // *opt_IF_ELSE, *listmaker, *testlist_comp, *lambdef, *subscript, 
     // *opt_test_only, *sliceop, *testlist, *dictorsetmaker, *argument, 
     // *testlist1, *star_COMMA_test, *star_test_COLON_test,
     // *plus_COMMA_test, *dictarg, *listarg
	: or_test opt_IF_ELSE                   { $$ = $1; }//std::cout << "test " << std::endl;}
	| lambdef                               { $$ = $1; }//std::cout << "test" << std::endl;} 
	;
opt_IF_ELSE // Used in: test
	: IF or_test ELSE test    					{ $$ = $1; std::cout << "opt_IF_ELSE" << std::endl;}
	| %empty                                      {}
	;
or_test // Used in: old_test, test, opt_IF_ELSE, or_test, comp_for
	: and_test 									{ $$ = $1; }//std::cout << "or_test" << std::endl;}
	| or_test OR and_test                          { $$ = $1; }
	;
and_test // Used in: or_test, and_test
	: not_test 									{ $$ = $1; }//std::cout << "and_test" << std::endl;}
	| and_test AND not_test
	;
not_test // Used in: and_test, not_test
	: NOT not_test                              {}
	| comparison 								{ $$ = $1; }//std::cout << "not_test" << std::endl;}
	;
comparison // Used in: not_test, comparison
	: expr 										{ $$ = $1; }//std::cout << "comparison" << std::endl;}
	| comparison comp_op expr
	;
comp_op // Used in: comparison
	: LESS
	| GREATER
	| EQEQUAL
	| GREATEREQUAL
	| LESSEQUAL
	| GRLT
	| NOTEQUAL
	| IN
	| NOT IN
	| IS
	| IS NOT
	;
expr // Used in: *exec_stmt, *with_item, *comparison, *expr,     ////*******************
     // *exprlist, star_COMMA_expr
	: xor_expr 									{ $$ = $1; }//std::cout << "expr" << std::endl;}
	| expr BAR xor_expr
	;
xor_expr // Used in: expr, xor_expr
	: and_expr 									{ $$ = $1; }//std::cout << "xor_expr" << std::endl;}
	| xor_expr CIRCUMFLEX and_expr
	;
and_expr // Used in: xor_expr, and_expr
	: shift_expr 								{ $$ = $1; }//std::cout << "and_expr" << std::endl; }
	| and_expr AMPERSAND shift_expr
	;
shift_expr // Used in: and_expr, shift_expr
	: arith_expr 								{ $$ = $1; }//std::cout << "shift_expr" << std::endl;}
	| shift_expr pick_LEFTSHIFT_RIGHTSHIFT arith_expr
	;
pick_LEFTSHIFT_RIGHTSHIFT // Used in: shift_expr
	: LEFTSHIFT
	| RIGHTSHIFT
	;
arith_expr // Used in: shift_expr, arith_expr
	: arith_expr pick_PLUS_MINUS term {			
	      $2->setNodes($1, $3);
	      $$ = $2;
	    }
	| term 										{ $$ = $1; }//std::cout << "arith_expr" << std::endl;}
	;
pick_PLUS_MINUS // Used in: arith_expr
	: PLUS 										{ $$ = new AddNode("addition"); }
	| MINUS 									{ $$ = new SubNode("subtraction"); }
	;
term // Used in: arith_expr, term
	: factor 									{ $$ = $1; }//std::cout << "term " <<std::endl;}
	| term pick_multop factor 					{ 
	 $2->setNodes($1, $3); $$ = $2; }//std::cout << $2->getNodetype() << $3->getNodetype() <<  std::endl;}											      
	; 											
pick_multop // Used in: term
	: STAR 										{ $$ = new MultNode("multiply"); }
	| SLASH 									{ $$ = new DivNode("divide");  }
	| PERCENT 									{ $$ = new ModNode("modulus");}
	| DOUBLESLASH 								{ $$ = new DivDivNode("Floordivide"); }
	;
factor // Used in: term, factor, power
	: pick_unop factor                          { $1->setNodes(NULL, $2); $$ = $1; }
	| power 									{ $$ = $1; }//std::cout << "factor "  << $1->getNodetype() << std::endl; }
	;
pick_unop // Used in: factor
	: PLUS 										{ $$ = new UPosNode("integer"); }
	| MINUS 									{ $$ = new UMinNode("integer"); }
	| TILDE 									{}// $$ = TILDE; }
	;
power // Used in: factor
	: atom star_trailer DOUBLESTAR factor       { $$ = new ExpoNode("expo"); $$->setNodes($1, $4);   }
	| atom star_trailer							{ 
	  //std::cout << " power " << std::endl;
	  if($2->getNodetype().compare("paren") == 0){
		  		std::string var = $1->getKey();
		 		var.append("()");
		 		$$ = new AstCall("fcall", var); 
	  }
	  else{
	     $$ = $1;
	  }
    
    }
	;
star_trailer // Used in: power, star_trailer
	: trailer star_trailer 						{ $$ = $1; }//std::cout << " star_trailer " << std::endl; }
	| %empty 								    { $$ = new voidNode("void"); }	
	;
atom // Used in: power
	: LPAR opt_yield_test RPAR                  { $$ = new ParenNode("paren"); $$->setNodes($2, NULL);  }
	| LSQB opt_listmaker RSQB 					{}
	| LBRACE opt_dictorsetmaker RBRACE    		{}
	| BACKQUOTE testlist1 BACKQUOTE   			{}
	| NAME                          { 
	   

	    std::string var($1); 
	    $$ = new AstVar("var");
	    $$->setKey(var);
	   // std::cout << " NAME " << var << std::endl;
	}
	| INUMBER						{ std::string s($1); $$ = new AstNumber("integer", s); }
	| FNUMBER						{ std::string s($1); $$ = new AstNumber("float", s); } 
	//std::cout << s << " float number" << std::endl; }		
	| plus_STRING
	;
pick_yield_expr_testlist_comp // Used in: opt_yield_test
	: yield_expr 								{ $$ = $1; }
	| testlist_comp 							{ $$ = $1; }
	;
opt_yield_test // Used in: atom
	: pick_yield_expr_testlist_comp              { $$ = $1; }
	| %empty                                    {}
	;
opt_listmaker // Used in: atom
	: listmaker
	| %empty                                    {}
	;
opt_dictorsetmaker // Used in: atom
	: dictorsetmaker
	| %empty                                    {}
	;
plus_STRING // Used in: atom, plus_STRING
	: STRING plus_STRING                        {}
	| STRING                                    {}
	;
listmaker // Used in: opt_listmaker
	: test list_for              { $$ = $1; }//std::cout << "listmaker " << $1->getNodetype() << std::endl;  }
	| test star_COMMA_test       { $$ = $1; }//std::cout << "listmaker 2 " << $1->getNodetype() << std::endl;  }
	;
testlist_comp // Used in: pick_yield_expr_testlist_comp
	: test comp_for 						{ $$ = $1; }//std::cout << "testlist_comp " << $1->getNodetype() << std::endl;}
	| test star_COMMA_test                  { $$ = $1; }//std::cout << "testlist_comp " << $1->getNodetype() << std::endl;}
	;
lambdef // Used in: test
	: LAMBDA varargslist COLON test         { $$ = $1; }//std::cout << "lambdef " << $1->getNodetype() << std::endl;}
	| LAMBDA COLON test                      { $$ = $1; }//std::cout << "lambdef " << $1->getNodetype() << std::endl;
	;
trailer // Used in: star_trailer
	: LPAR opt_arglist RPAR                { $$ = new ParenNode("paren"); }
	| LSQB subscriptlist RSQB              {}
	| DOT NAME
	;
subscriptlist // Used in: trailer
	: subscript star_COMMA_subscript       {}
	;
subscript // Used in: subscriptlist, star_COMMA_subscript
	: DOT DOT DOT
	| test                                           { $$ = $1; }//std::cout << "subscript " << $1->getNodetype() << std::endl;  }
	| opt_test_only COLON opt_test_only opt_sliceop           { $$ = $1; }//std::cout << "subscript " << $1->getNodetype() << std::endl;  }
	;
opt_test_only // Used in: subscript
	: test                         { $$ = $1; }//td::cout << "opt_test_only " << $1->getNodetype() << std::endl;  }
	| %empty                        {}
	;
opt_sliceop // Used in: subscript
	: sliceop
	| %empty
	;
sliceop // Used in: opt_sliceop
	: COLON test                    { $$ = $1; }//std::cout << "sliceop " << $2->getNodetype() << std::endl; $$ = $1; }
	| COLON                         { $$ = $1; }//std::cout << "sliceop "  << std::endl; $$ = $1; }
	;
exprlist // Used in: del_stmt, for_stmt, list_for, comp_for
	: expr star_COMMA_expr            {std::cout << " exprlist " << std::endl; }
	;
testlist // Used in: *expr_stmt, *pick_yield_expr_testlist, 
         // *return_stmt, *for_stmt, *opt_testlist, *yield_expr
	: test star_COMMA_test                            { $$ = $1;  }//std::cout << "testlist "  << std::endl;  }
	;
dictorsetmaker // Used in: opt_dictorsetmaker
	: test COLON test pick_comp_for      { $$ = $1; }//std::cout << "dictorsetmaker " << $1->getNodetype() << std::endl; $$ = $1; }
	| test pick_for_test                 { $$ = $1; }//std::cout << "dictorsetmaker " << $1->getNodetype() << std::endl; $$ = $1; }
	;
pick_comp_for // Used in: dictorsetmaker
	: comp_for
	| star_test_COLON_test
	;
pick_for_test // Used in: dictorsetmaker
	: comp_for
	| star_COMMA_test
	;
classdef // Used in: decorated, compound_stmt
	: CLASS NAME LPAR opt_testlist RPAR COLON suite
	| CLASS NAME COLON suite
	;
opt_testlist // Used in: classdef
	: testlist                               {}// std::cout << "opt_testlist " << $1->getNodetype() << std::endl; $$ = $1; }
	| %empty                                 {}
	;
arglist // Used in: opt_arglist, arglist
	: argument COMMA arglist
	| argument COMMA
	| argument                            { $$ = $1; }
	| listarg COMMA arglist_postlist
	| listarg                             { $$ = $1; }
	| dictarg 							  { $$ = $1; }
	;
argument // Used in: arglist, arglist_postlist
	: test opt_comp_for         { $$ = $1; }//std::cout << "argument " << std::endl;}
	| test EQUAL test           { $$ = $1; }//std::cout << "argument " << std::endl;}
	;
opt_comp_for // Used in: argument
	: comp_for
	| %empty                               {}
	;
list_iter // Used in: list_for, list_if
	: list_for
	| list_if
	;
list_for // Used in: listmaker, list_iter
	: FOR exprlist IN testlist_safe list_iter
	| FOR exprlist IN testlist_safe
	;
list_if // Used in: list_iter
	: IF old_test list_iter
	| IF old_test
	;
comp_iter // Used in: comp_for, comp_if
	: comp_for
	| comp_if
	;
comp_for // Used in: testlist_comp, pick_comp_for, pick_for_test, 
         // opt_comp_for, comp_iter
	: FOR exprlist IN or_test comp_iter
	| FOR exprlist IN or_test
	;
comp_if // Used in: comp_iter
	: IF old_test comp_iter
	| IF old_test
	;
testlist1 // Used in: atom, testlist1
	: testlist1 COMMA test      { $$ = $1; std::cout << "testlist1 "  << std::endl; }
	| test                     { $$ = $1; std::cout << "testlist1 "  << std::endl;  }
	;
encoding_decl // Used in: start
	: NAME                                   { }//std::cout << "encoding_declr" << std::endl; }
	;
yield_expr // Used in: pick_yield_expr_testlist, yield_stmt, 
           // pick_yield_expr_testlist_comp
	: YIELD testlist                   { }//std::cout << "yield_expr " << $1->getNodetype() << std::endl;}
	| YIELD
	;
star_fpdef_notest // Used in: fplist, star_fpdef_notest
	: COMMA fpdef star_fpdef_notest
	| COMMA
	| %empty
	;
star_COMMA_expr // Used in: exprlist, star_COMMA_expr
	: COMMA expr star_COMMA_expr
	| COMMA
	| %empty
	;
star_COMMA_fpdef // Used in: varargslist, star_COMMA_fpdef
	: COMMA fpdef opt_EQUAL_test star_COMMA_fpdef      {}//std::cout << "star_COMMA_fpdef" << std::endl;}
	| COMMA                                             {}//std::cout << "star_COMMA_fpdef" << std::endl;}
	| %empty     
	;
star_COMMA_test // Used in: opt_test, listmaker, testlist_comp, testlist, pick_for_test, star_COMMA_test
	: COMMA test star_COMMA_test        { $$ = $2; }//std::cout << "star_COMMA_test " << $2->getNodetype() << std::endl;  }
	| COMMA                             {}
	| %empty                            {}
	;
star_test_COLON_test // Used in: pick_comp_for, star_test_COLON_test
	: COMMA test COLON test star_test_COLON_test    {}//std::cout << "star_test_COLON_test" << std::endl;}
	| COMMA                                          {}//std::cout << "star_test_COLON_test" << std::endl;}
	| %empty {}
	;
star_COMMA_subscript // Used in: subscriptlist, star_COMMA_subscript
	: COMMA subscript star_COMMA_subscript
	| COMMA
	| %empty
	;
star_COMMA_import_as_name // Used in: import_as_names, 
                          // star_COMMA_import_as_name
	: COMMA import_as_name star_COMMA_import_as_name
	| COMMA
	| %empty
	;
plus_COMMA_test // Used in: opt_test_2, plus_COMMA_test
	: COMMA test plus_COMMA_test            {}//std::cout << "plus_COMMA_test" << std::endl;}
	| COMMA test COMMA                      {}//std::cout << "plus_COMMA_test" << std::endl;}
	| COMMA test                            {}//std::cout << "plus_COMMA_test" << std::endl;}
	;
plus_COMMA_old_test // Used in: testlist_safe, plus_COMMA_old_test
	: COMMA old_test plus_COMMA_old_test
	| COMMA old_test COMMA
	| COMMA old_test
	;
dictarg // Used in: arglist, arglist_postlist
	: DOUBLESTAR test                   {}//std::cout << "with_item" << std::endl;}
	;
listarg // Used in: arglist
	: STAR test      {std::cout << "with_item" << std::endl;}
	;
arglist_postlist // Used in: arglist, arglist_postlist
	: argument COMMA arglist_postlist
	| dictarg
	| argument
	;
small_stmt_STAR_OR_SEMI // Used in: simple_stmt, small_stmt_STAR_OR_SEMI
    : SEMI small_stmt small_stmt_STAR_OR_SEMI     {}//std::cout << "small_stmt_STAR_OR_SEMI" << std::endl; }
	| %empty                                  {}
	;

%%

#include <stdio.h>
void yyerror (char const *s) {
	fprintf (stderr, "%d: %s with [%s]\n", yylineno, s, yytext);
}

